#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
glossary_apply_patch.py

Apply a glossary patch file to the target glossary.
The patch is generated by glossary_autopromote.py and reviewed by humans.

Usage:
  python scripts/glossary_apply_patch.py \\
    --patch data/glossary_patch.yaml \\
    --target glossary/zhCN_ruRU/base.yaml \\
    --backup  # optional: create backup before modifying

Operations supported:
  - append_entries: Add new entries to glossary
  - update_entries: Update existing entries
  - remove_entries: Remove entries by term_zh
"""

import argparse
import shutil
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any

try:
    import yaml
except ImportError:
    yaml = None


def load_yaml_file(path: str) -> dict:
    """Load YAML file."""
    if yaml is None:
        raise RuntimeError("PyYAML required: pip install pyyaml")
    if not Path(path).exists():
        return {}
    with open(path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f) or {}


def dump_yaml_file(path: str, obj: Any) -> None:
    """Write YAML file."""
    if yaml is None:
        raise RuntimeError("PyYAML required: pip install pyyaml")
    Path(path).parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        yaml.safe_dump(obj, f, allow_unicode=True, sort_keys=False, default_flow_style=False)


def apply_append_entries(glossary: dict, entries: List[dict]) -> int:
    """
    Append new entries to glossary.
    Skips duplicates (same term_zh + term_ru).
    Returns count of entries added.
    """
    if "entries" not in glossary:
        glossary["entries"] = []
    
    existing = set()
    for e in glossary["entries"]:
        k = ((e.get("term_zh") or "").strip(), (e.get("term_ru") or "").strip())
        existing.add(k)
    
    added = 0
    for entry in entries:
        term_zh = (entry.get("term_zh") or "").strip()
        term_ru = (entry.get("term_ru") or "").strip()
        
        if not term_zh:
            continue
        
        k = (term_zh, term_ru)
        if k in existing:
            print(f"  â­ï¸  Skip duplicate: {term_zh} â†’ {term_ru}")
            continue
        
        glossary["entries"].append(entry)
        existing.add(k)
        added += 1
        print(f"  âœ… Added: {term_zh} â†’ {term_ru} [{entry.get('status', 'proposed')}]")
    
    return added


def apply_update_entries(glossary: dict, entries: List[dict]) -> int:
    """
    Update existing entries by term_zh match.
    Returns count of entries updated.
    """
    if "entries" not in glossary:
        return 0
    
    # Build index
    idx: Dict[str, int] = {}
    for i, e in enumerate(glossary["entries"]):
        term_zh = (e.get("term_zh") or "").strip()
        if term_zh:
            idx[term_zh] = i
    
    updated = 0
    for entry in entries:
        term_zh = (entry.get("term_zh") or "").strip()
        if not term_zh or term_zh not in idx:
            print(f"  â­ï¸  Skip (not found): {term_zh}")
            continue
        
        i = idx[term_zh]
        old = glossary["entries"][i]
        
        # Merge fields
        for k, v in entry.items():
            if v is not None:
                old[k] = v
        
        updated += 1
        print(f"  âœ… Updated: {term_zh}")
    
    return updated


def apply_remove_entries(glossary: dict, entries: List[dict]) -> int:
    """
    Remove entries by term_zh match.
    Returns count of entries removed.
    """
    if "entries" not in glossary:
        return 0
    
    to_remove = set()
    for entry in entries:
        term_zh = (entry.get("term_zh") or "").strip()
        if term_zh:
            to_remove.add(term_zh)
    
    original_count = len(glossary["entries"])
    glossary["entries"] = [
        e for e in glossary["entries"]
        if (e.get("term_zh") or "").strip() not in to_remove
    ]
    removed = original_count - len(glossary["entries"])
    
    for term_zh in to_remove:
        print(f"  ğŸ—‘ï¸  Removed: {term_zh}")
    
    return removed


def main():
    ap = argparse.ArgumentParser(description="Apply glossary patch")
    ap.add_argument("--patch", required=True, help="Patch YAML file")
    ap.add_argument("--target", default=None, help="Target glossary YAML (overrides patch)")
    ap.add_argument("--backup", action="store_true", help="Create backup before modifying")
    ap.add_argument("--dry_run", action="store_true", help="Show what would be done without writing")
    args = ap.parse_args()
    
    print(f"ğŸ“¦ Glossary Patch Applier")
    print(f"   Patch: {args.patch}")
    print()
    
    # Load patch
    patch = load_yaml_file(args.patch)
    if not patch:
        print("âŒ Empty or invalid patch file")
        return 1
    
    op = patch.get("op", "append_entries")
    target_path = args.target or patch.get("target_glossary")
    entries = patch.get("entries", [])
    
    if not target_path:
        print("âŒ No target glossary specified (use --target or set in patch)")
        return 1
    
    print(f"   Target: {target_path}")
    print(f"   Operation: {op}")
    print(f"   Entries: {len(entries)}")
    print()
    
    # Load target glossary
    glossary = load_yaml_file(target_path)
    
    # Initialize if empty
    if not glossary:
        glossary = {
            "meta": {
                "scope": "unknown",
                "language_pair": patch.get("language_pair", "unknown"),
                "version": 1,
            },
            "entries": []
        }
    
    # Create backup if requested
    if args.backup and Path(target_path).exists() and not args.dry_run:
        backup_path = f"{target_path}.bak.{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        shutil.copy2(target_path, backup_path)
        print(f"ğŸ“‹ Created backup: {backup_path}")
        print()
    
    # Apply operation
    print(f"ğŸ”§ Applying {op}...")
    
    count = 0
    if op == "append_entries":
        count = apply_append_entries(glossary, entries)
    elif op == "update_entries":
        count = apply_update_entries(glossary, entries)
    elif op == "remove_entries":
        count = apply_remove_entries(glossary, entries)
    else:
        print(f"âŒ Unknown operation: {op}")
        return 1
    
    print()
    
    # Update version
    if "meta" in glossary:
        glossary["meta"]["version"] = glossary["meta"].get("version", 0) + 1
        glossary["meta"]["last_updated"] = datetime.now().isoformat()
    
    # Write result
    if args.dry_run:
        print(f"ğŸ” Dry run: would modify {count} entries")
        print(f"   (use without --dry_run to apply)")
    else:
        dump_yaml_file(target_path, glossary)
        print(f"âœ… Applied {count} changes to {target_path}")
    
    return 0


if __name__ == "__main__":
    exit(main())
